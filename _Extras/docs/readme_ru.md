WHM_Core - Ядро для разработки
==============================

Основные проблемы при разработке дополнений под XenForo
-------------------------------------------------------
При разработке и поддержке дополнений для XenForo основные проблемы с которыми сталкивается разработчик:

 1. Невозможность расширения базовых классов XenForo, особенно статических хелперов.
 2. Невозможность расширения одним динамическим классом нескольких классов XenForo из-за невозможности повторного декларирования 1 класса
 3. Трудность пробрасывания входных данных из контроллера в датарайтер при расширении функционала основных типов данных (узлы, сообщения, темы)
 4. Неудобство в разработке когда надо изменить какой-либо обработчик в админке, вместо простой правки кода, следовательно любое добавление обработчика требует обязательного обновления хака через админку
 5. Невозможность простого использования репозитариев для каждого отдельного дополнения (все находятся в одном дереве, что не дает нормаkьно использовать функционал IDE по работе с системами контроля версий)


Все эти проблемы и неудобства позволяет решить ядро

Общие положения
---------------
 Ядро для работы и реализации функционала использует собственный автозагрузчик классов и собственный аналог реестра очень похож на реестр XenForo_Application, но со своими особенностями

Автозагрузчик WHM_Core_Autoloader
---------------------------------
Для включения полного функционала ядра, кроме установки дополнения через админку, надо включить подмену стандартного автозагрузчика XenForo.

Самый ранний вараинт без правки оригинальный файлов - это добавление инициализации автозагрузчика в `config.php`, которое никак не повлияет на обновление форума или на установку каких либо сторонних хаков и инициализируется приложением достаточно рано чтобы была возможность перехватить практически любой класс после его загрузки.

### Обычный режим автозагрузчика. Production
Для включения автолоадера ядра надо в начало `config.php` добавить

~~~php
WHM_Core_Autoloader::getProxy();
~~~

При таком подходе `WHM_Core_Autoloader` грузится прямо перед `XenForo_FrontController` что позволяет при желании расширить  :

~~~
1. index.php
2. library/XenForo/Autoloader.php
3. library/XenForo/Application.php
4. library/Zend/Registry.php
5. library/Lgpl/utf8.php
6. library/Zend/Config.php
7. library/config.php
8. library/WHM/Core/Autoloader.php
9. library/XenForo/FrontController.php
~~~

Хоть расширить теоретически можно любой класс, но практически удобное API, с динамическим наследованием, аналогичное стандартному API XenForo для обработчиков событий можно сделать только после стандартной загрузки `XenForo_CodeEvent`, и после прогрузки всех основных обработчиков событий из базы, т.е. после:

~~~
9.  library/XenForo/FrontController.php
10. library/XenForo/Dependencies/Public.php
11. library/XenForo/Dependencies/Abstract.php
12. library/Zend/*
    ...
17. library/XenForo/Model.php
18. library/XenForo/Model/DataRegistry.php
19. library/XenForo/CodeEvent.php
20. library/Zend/Db*
    ...
30. library/WHM/Core/Application.php
~~~

### Режим разработки. Отдельная папка для каждого аддона.
При разработке удобно когда каждый аддон лежит в полностью своей папке, что практически не осуществимо в текущей структуре папок XenForo (php, js и стили - все в разных папках).
Для этого у автолоадера есть режим поиска файлов в папке по альтернативному пути, причем внутри файлы хака могут располагаться исходя из нескольких вариантов соглашений (связано с тем что разработчики как только не называют свои классы при создании расширения).

Метод автозагрузчика для указания папки поиска дополнений `setAddonDir`.
Пример: инициализируем автозагрузчик и предварительно ищем дополнения в папке `/addons/`:

~~~php
WHM_Core_Autoloader::getProxy()->setAddonDir('addons');
~~~
Если автозагрузчик не находит класс по альтернативному пути, то он ищет его по первоначальному пути, т.е. в `/library/`.

#### Соглашения по структуре и именованию папок дополнений
Разработчики при наименовании своих дополнений обычно используют 2 варианта наименования классов короткий и длинный:

1. Короткий - `AddOnName_SubClass` (соответсвенно хранится в `/library/AddOnName/SubClass.php`)
2. Длинный - `Author_AddOnName_SubClass` (соответсвенно хранится в `/library/Author/AddOnName/SubClass.php`)

Соотвественно id дополнения на основе названия классов можно считать `addonname` и `author_addonname` (для удобства http редиректов будут в нижнем регистре).
После чего простая последовательная проверка на наличие папок `author_addonname` и `addonname` позволяет точно сказать по какому соглашению проименованы классы в аддоне.

Учитывая уже сложившуюся структуру SVN репозиториев для WHM, когда файлы классов лежат в 1 папке `/library/WHM/AddonName/` (т.е. длинное наименование), а все дополнительные файлы (js/xml/style) лежат в `/library/WHM/AddonName/_Extras/`, то автозагрузчик обрабатывает и этот вариант хранения готового дополнения.

Т.е. дополнения с длинным наименованиями можно хранить так:

+ **Расположение по умолчанию:**
	+ xml файлов с аддоном и языками может вообще не быть в папках

~~~
/library/WHM/SomeAddon/Model/Forum.php
/library/WHM/SomeAddon/Model/Thread.php
/library/WHM/SomeAddon/Listener.php
/js/whm/someaddon/thread.js
/styles/whm/someaddon/image.jpg
~~~

+  **WHM-соглашение:**
	+ папка дополнения первые 2 части класса через подчеркивание в нижнем регистре
	+ остальная часть пути класса как в library
	+ все остальное лежит в _Extras
	+ xml лежит в _Extras

~~~
/addons/whm_someaddon/Model/Forum.php
/addons/whm_someaddon/Model/Thread.php
/addons/whm_someaddon/Listener.php
/addons/whm_someaddon/_Extras/js/whm/someaddon/thread.js
/addons/whm_someaddon/_Extras/styles/whm/someaddon/image.jpg
/addons/whm_someaddon/_Extras/xml/language.xml
~~~

+  **FullPath-соглашение:**
	+ папка дополнения первые 2 части класса через подчеркивание в нижнем регистре
	+ все кроме xml лежит в upload по полному пути
	+

~~~
/addons/whm_someaddon/upload/library/WHM/SomeAddon/Model/Forum.php
/addons/whm_someaddon/upload/library/WHM/SomeAddon/Model/Thread.php
/addons/whm_someaddon/upload/library/WHM/SomeAddon/Listener.php
/addons/whm_someaddon/upload/js/whm/someaddon/thread.js
/addons/whm_someaddon/upload/styles/whm/someaddon/image.jpg
/addons/whm_someaddon/xml/language.xml
~~~

Для дополнений с **коротким** стилем наименования используется только **FullPath-соглашение** только в качестве имени папки используется первая часть класса.

Во всех соглашениях за счет нижнего регистра названия аддона и присутствия частей названия аддона в путях к статическим файлам, легко сделать редирект с `/(js|styles)/` на соответствующую папку аддона.

#### Привязка классов к определенному дополнению
Если дополнение использует сторонние классы, с другим префиксом/неймспейсом (типичный пример дополнение `TMS` использует сторонние классы `Diff_*`), то может понадобиться принудительно указать в какой папке искать класс с заданным префиксом.

Для это используется метод автозагрузчика `addAddonMap`, пример использования ниже в примере конфига.

#### Типичный конфиг
Типичный конфиг, который добвляется в `config.php`, когда надо чтобы дополнения лежали в `/addons/`, при условии что сам хак ядра тоже будет лежать в этой папке:

~~~php
//вручную инклудим автозагрузчик
include('addons/whm_core/Autoloader.php');
//инициализируем автозагрузчик и устанавливаем путь поиска дополнений
WHM_Core_Autoloader::getProxy()->setAddonDir('addons');

//указываем что надо искать классы Diff_* в папке аддона tms
WHM_Core_Autoloader::getProxy()->addAddonMap(
	array(
	     'Diff' => 'tms'    //в качестве ключа самая первая/первые две части класса
	                        //в качестве значения папка дополнения
	)
);
~~~


Расширенная работа с событиями. Класс WHM_Core_Listener
-------------------------------------------------------
Одно из неудобств XenForo при активной разработке это необходимость прописывать любое событие в админке. В XenForo можно работать напрямую с событиями через `XenForo_CodeEvent`, но функционал там только базовый, только статические методы и API не очень удобное. Поэтому был написан класс для расширенной работы с событиями `WHM_Core_Listener`, наследуемый от `XenForo_CodeEvent`, что позволило получить доступ ко всем оригинальным обработчикам событий XenForo.

### Базовая работа с событиями
Для удобства описания всех обработчиков создано отдельное событие `init_listeners`, которое запускается из автозагрузчика, до всех остальных событий XenForo, даже раньше `init_dependencies`.

Сигнатура события:

~~~php
public static function initListeners(WHM_Core_Listener $events)
~~~
**Внимание!** Событие стартует до полной инициализации приложения, например, еще не загружены опции, поэтому лучше использовать в нем только методы `WHM_Core_Listener`.

### Добавление событий
Внутри события в объекте `$events` доступен оригинальный массив (данные об обработчиках из админки) обработчиков событий `$listeners`, где ключи названия событий, а значения массивы колбеков-обработчиков этих событий.
Пример добавления нескольких событий в конец очереди:

~~~php
$events->listeners['init_application'][] = array('Some_Class_Listener', 'initApplication');
$events->listeners['template_hook'][] = array('Some_Class_Listener', 'templateHook');
~~~
Также обработчки можно добавлять используя методы:
`prependListener($event, $callback)` - добавить обработчик в начало очереди события
`appendListener($event, $callback)` - добавить обработчик в конец очереди события
`addListeners(array $listeners, $prepend = false)` - добавить набор обработчиков для событий в начало или конец очереди, т.е. попросту объединение 2-х массивов обработчиков в нужном порядке.

### Управление наследованием
В XenForo очень удобно реализовано расширение классов через динамическое наследование используя `load_class_*` события, но описание их приходится делать в нескольких местах, также приходится писать много однотипного кода (обработчики событий `load_class_*` практически всегда одинаковые только отличаются названием классов), хотя в 99% случаев надо просто расширить какой-то один класс другим.
Для облегчения этого и чтобы все можно было прописать в 1 месте без необходимости делать обработчики для `load_class_*` событий добавлены специальные методы для описания наследования. Т.е. достаточно прописать в событии `init_listeners` цепочку наследования, обработчики событий для динамического наследования создадутся автоматом.

Для этого используется метод
`public function addExtenders($extenders, $prepend = false)`

Пример описания расширения `XenForo_DataWriter_Page` с помощью `Some_Addon_DataWriter_Node` и `Some_Addon_DataWriter_Page`, а также
 расширения `XenForo_ViewPublic_Page_View` с помощью `Some_Addon_ViewPublic_Page_View`:

~~~php
$events->addExtenders(
     'datawriter' => array(
          'XenForo_DataWriter_Page' => array(
              'Some_Addon_DataWriter_Page'
          ),
          'XenForo_DataWriter_Forum' => array(
              'Some_Addon_DataWriter_Forum'
          )
     ),
     'view' => array(
          'XenForo_ViewPublic_Page_View' => array(
              'Some_Addon_ViewPublic_Page_View'
          )
     )
);
~~~
**Внимание!** Обработчики событий, автоматически сгенерированные для событий `load_class_*` на основе описания `addExtenders` запускаются **в самую первую очередь** до обработчиков прописанных как админке XenForo, так и обработчиков прописанных через `listeners` методы.

### Наследование базовых классов XenForo
Используя собственный автозагрузчик файлов можно решить проблему наследования нерасширяемых классов XenForo.
Например, чтобы динамически расширить класс который вызывается по прямому имени - тот же, `XenForo_Link`, можно сделать физическую копию класса, но с измененным именем, например `XFProxy_XenForo_Link`, потом от него динамически отнаследовать цепочку как любой динамический класс в XenForo (задекларировать через `eval`), после чего опять же через `eval` задекларировать класс `XenForo_Link`.

Т.е. вместо инклуда файла с `XenForo_Link` получаем цепочку:

1. Создание копии файла с подменой оригинального имени класса на класс с префиксом, т.е. `XFProxy_XenForo_Link`.
2. Стандартное динамическое декларирование с наследованием цепочки `XFCP_*` классов  через `eval` с инклудами файлов аддонов.
3. Декларирование оригинального имени класса `XenForo_Link` через `eval`, который расширяет последний класс в цепочке динамического наследования из предыдущего п.2.

Для удобной работы с таким прокси наследованием добавлено новое событие `load_class_proxy_class` по интерфейсу аналогичное остальным `load_class_*` событиям, только с некоторыми особенностями связанными со спецификой такого наследования.

#### Особенности реализации
Копия создается при первой инициализации прокси класса с проверкой времени модификации файла, так что это не вызывает проблем в производительности на продакшене или проблем частого обновления файлов при разработке.

Т.к. это динамическое наследование происходит внутри автозагрузчика классов, то проверять для каждого загружаемого класса возможность расширения его с помощью события `load_class_proxy_class` неэффективно в плане производительности, поэтому для этого сделан отдельный метод классf `WHM_Core_Autoloader` - `public function addClass($class = '')`. Только после добавления имени обарбатываемого класса в автозагрузчик для этого класса в момент автозагрузки запустится событие `load_class_proxy_class`.

Пример добавления класса `Some_Class` для обработки событием `load_class_proxy_class`

~~~php
WHM_Core_Autoloader::getProxy()->addClass('Some_Class')
~~~

При использовании метода `addExtenders` для события `load_class_proxy_class` классы автоматически добавятся в автолоадер, т.е. при вызове:

~~~php
$events->addExtenders(
	array(
	     'proxy_class' => array(
		     'Some_XenForo_Class' => array(
			     'Some_AddOn_Class'
		     )
	     )
	)
);
~~~
вызывать `addClass('Some_XenForo_Class')` нет необходимости.
Т.е. наследованиt через метод `addExtenders` - рекомендованное использование.

**Внимание!** При расширении абстрактных классов вместо имени класса каким надо расширить указывается массив из этого имени и 2-го поля со значением `'abstract'`, например:

~~~php
$events->addExtenders(
	array(
	    'proxy_class' => array(
			'XenForo_DataWriter' => array(
				array('AddOn_DataWriter_Abstract', 'abstract')
			)
		)
	)
);
~~~

### Мультинаследование или наследование одним классом аддона нескольких классов XenForo.
Из-за невозможности повторного декларирования одного и того же класса, нельзя использовать 1 класс для расширения однотипных классов XenForo. Типичный пример  - датарайтеры узлов или обработчики ббкодов. Например, чтобы добавить функционал во все типы узлов приходится в аддоне создавать отдельный класс для каждого типа узла, даже если содержание в них будет полностью одинаковым.
Но используя метод автоматического создания копии при повторном декларировании (метод аналогичный методу расширения базовых классов ксена описанному выше), можно добиться мультинаследованияпрокси классов без дублирования кода.

Например, можно расширить 1 классом `Some_Addon_DataWriter_Node`, три класса: `XenForo_DataWriter_Node`, `XenForo_DataWriter_Page` и `XenForo_DataWriter_Forum` и это не вызовет ошибки даже если в коде все 3 класса будут одновременно использоваться.

~~~php
$events->addExtenders(
     'datawriter' => array(
          'XenForo_DataWriter_Node' => array(
              'Some_Addon_DataWriter_Node'
          ),
          'XenForo_DataWriter_Page' => array(
              'Some_Addon_DataWriter_Node'
          ),
          'XenForo_DataWriter_Forum' => array(
              'Some_Addon_DataWriter_Node'
          )
     )
);
~~~
**Внимание!** Мультинаследование работает только при описании наследования через `addExtenders`, во всех других случаях повторное декларирование будет вызывать стандартную ошибку PHP.
